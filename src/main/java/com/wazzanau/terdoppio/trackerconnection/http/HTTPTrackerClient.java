package com.wazzanau.terdoppio.trackerconnection.http;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.lang.Thread.UncaughtExceptionHandler;
import java.net.Inet4Address;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import com.wazzanau.terdoppio.ByteUtils;
import com.wazzanau.terdoppio.bencode.BEDictionary;
import com.wazzanau.terdoppio.bencode.BEncoding;
import com.wazzanau.terdoppio.bencode.DecodingException;
import com.wazzanau.terdoppio.trackerconnection.TrackerClient;

/**
 * A client for doing tracker HTTP request.
 * @author marco.nicolini@gmail.com
 *
 */
public class HTTPTrackerClient extends TrackerClient {

	private static final String ANNOUNCE_PARAM_INFO_HASH = "info_hash";
	private static final String ANNOUNCE_PARAM_PEER_ID = "peer_id";
	private static final String ANNOUNCE_PARAM_PORT = "port";
	private static final String ANNOUNCE_PARAM_UPLOADED = "uploaded";
	private static final String ANNOUNCE_PARAM_DOWNLOADED = "downloaded";
	private static final String ANNOUNCE_PARAM_LEFT = "left";
	private static final String ANNOUNCE_PARAM_COMPACT = "compact";
	private static final String ANNOUNCE_PARAM_NO_PEER_ID = "no_peer_id";
	private static final String ANNOUNCE_PARAM_EVENT = "event";
	private static final String ANNOUNCE_PARAM_IP = "ip";
	private static final String ANNOUNCE_PARAM_NUMWANT = "numwant";
	private static final String ANNOUNCE_PARAM_KEY = "key";
	private static final String ANNOUNCE_PARAM_TRACKERID = "trackerid";
	private static final String SCRAPE_PARAM_INFO_HASH = "info_hash";

	/**
	 * Set parameters are encoded in the URI
	 */
	private final URI trackerUrl; 

	/**
	 * If null, it means that scraping is not supported by the tracker.
	 */
	private final URI scrapeUrl;

	//
	// the supported parameters for the Tracker's request
	//

	//	private String peerId; 					// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup. See peer_id below for common client encodings of this field.
	//	private int port = 0; 					// The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889. Clients may choose to give up if it cannot establish a port within this range. ))
	//	private long uploaded = 0; 				// uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the concensus is that this should be the total number of bytes uploaded. 
	//	private long downloaded = 0; 			// downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total number of bytes downloaded. 
	//	private long left = 0; 					//  left: The number of bytes this client still has to download in base ten ASCII. Clarification: The number of bytes needed to download to be 100% complete and get all the included files in the torrent. 
	private boolean compact = false; 		// compact: Setting this to 1 indicates that the client accepts a compact response. The peers list is replaced by a peers string with 6 bytes per peer. The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order). It should be noted that some trackers only support compact responses (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response unless the request contains "compact=0" (in which case they will refuse the request.) 
	private boolean noPeerId = false; 		// no_peer_id: Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled. 
	//	private Event event = null; 			//  event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified). If not specified, then this request is one performed at regular intervals.
	//    										//	started: The first request to the tracker must include the event key with this value.
	//											//	stopped: Must be sent to the tracker if the client is shutting down gracefully.
	//											//	completed: Must be sent to the tracker when the download completes. However, must not be sent if the download was already 100% complete when the client started. Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
	//	private String ip = null;				// optional dotted quad
	//	private	long numWant = 50; 				// Optional. Number of peers that the client would like to receive from the tracker. This value is permitted to be zero. If omitted, typically defaults to 50 peers. 
	private String key = null; 				// Optional. An additional client identification mechanism that is not shared with any peers. It is intended to allow a client to prove their identity should their IP address change.
	private String trackerId = null; 		// If a previous announce contained a tracker id, it should be set here.

	/**
	 * Holds the additional "custom" parameters.
	 */
	private Map<String, String> customRequestParameters = new HashMap<String, String>();

	public HTTPTrackerClient(URI announceUrl, String peerId, byte[] infoHash, byte[] ipAddress, int port) {
		super(peerId, infoHash, ipAddress, port);
		this.trackerUrl = announceUrl;
		this.scrapeUrl = toScrapeUrl(announceUrl);
	}

	public boolean isScrappingSupported() {
		return scrapeUrl != null;
	}

	public URI getTrackerUrl() {
		return trackerUrl;
	}

	public URI getScrapeUrl() {
		return scrapeUrl;
	}

	/**
	 * Generic method to put a parameter in the tracker request. Unless you're trying to do something custom
	 * you should not use this method but the specialized setters for the announce request.
	 * @param param
	 * @param value
	 */
	public void setRequestParam(String param, String value) {
		customRequestParameters.put(param, value);
	}

	/**
	 * Execute a request against the tracker's announce url.
	 * @return
	 * @throws BadTrackerResponseException if the response from the tracker cannot be parsed or is not properly recognized.
	 * @throws TrackerConnectionException if there is an exception in the http communication
	 * @throws BadTrackerUrlException if the URL for the request cannot be constructed from the given parameters
	 * @throws  
	 */
	public HTTPTrackerResponse request(Event event) throws BadTrackerResponseException, TrackerConnectionException, BadTrackerUrlException {				
		// add the parameters
		URI announceRequestUrl;
		try {
			announceRequestUrl = getAnnounceUrlWithParameters(trackerUrl, event);
		} catch (URISyntaxException | UnknownHostException e) {
			throw new BadTrackerUrlException(e);
		}

		// perform the HTTP get
		BEDictionary responseDict = performHTTPGet(announceRequestUrl);
		try {
			return HTTPTrackerResponse.fromDict(responseDict);
		} catch (DecodingException e) {
			throw new BadTrackerResponseException(e);
		}
	}

	public BEDictionary scrapeRequest() throws BadTrackerResponseException, TrackerConnectionException, BadTrackerUrlException {
		return scrapeRequest(null);
	}

	/**
	 * Execute a scrape request to the tracker's scrape url. 
	 * @param infoHash, can also be null, the scrape request will be "global" for all info hashes served by the tracker. Note that this is discouraged.
	 * @return
	 * @throws BadTrackerResponseException
	 * @throws TrackerConnectionException
	 * @throws BadTrackerUrlException 
	 */
	public BEDictionary scrapeRequest(String infoHash) throws BadTrackerResponseException, TrackerConnectionException, BadTrackerUrlException  {
		if (isScrappingSupported()) {
			throw new UnsupportedOperationException("Scrape is not supported for this tracker: [" + trackerUrl + "]");
		}

		URI scrapeUrlWParams;
		try {
			scrapeUrlWParams = addParamToUrlIfNotNullOrEmpty(scrapeUrl, SCRAPE_PARAM_INFO_HASH, infoHash);
		} catch (URISyntaxException e) {
			throw new BadTrackerUrlException(e);
		}

		return performHTTPGet(scrapeUrlWParams);
	}

	/**
	 * Augments the uri with parameters, both standard 
	 * @param baseUri
	 * @return
	 * @throws URISyntaxException
	 * @throws UnknownHostException 
	 */
	private URI getAnnounceUrlWithParameters(URI baseUri, Event event) throws URISyntaxException, UnknownHostException {
		URIBuilder builder = new URIBuilder(baseUri);

		// add the supported parameters
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_INFO_HASH, ByteUtils.toString(getInfoHash()));
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_PEER_ID, getPeerId());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_PORT, getPort());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_UPLOADED, getUploaded());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_DOWNLOADED, getDownloaded());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_LEFT, getLeft());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_COMPACT, compact ? 1 : 0);
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_NO_PEER_ID, noPeerId ? 1 : 0);
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_EVENT, event);	
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_IP, Inet4Address.getByAddress(getIpAddress()));
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_NUMWANT, getNumWant());
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_KEY, key);
		addIfNotNullNorEmpty(builder, ANNOUNCE_PARAM_TRACKERID, trackerId);

		// add all the "custom" parameters
		for (Map.Entry<String, String> item: customRequestParameters.entrySet()) {
			addIfNotNullNorEmpty(builder, item.getKey(), item.getValue());
		}
		return builder.build();
	}

	/**
	 * Adds a parameter to the builder only if it's not null and it's not empty as a string. 
	 * @param builder
	 * @param param
	 * @param value
	 */
	private void addIfNotNullNorEmpty(URIBuilder builder, String param, Object value) {
		if (value != null) {
			String valueAsString = value.toString();
			if (!valueAsString.isEmpty()) {
				builder.addParameter(param, valueAsString);	
			}
		}
	}

	private URI addParamToUrlIfNotNullOrEmpty(URI url, String param, String value) throws URISyntaxException {
		URIBuilder builder = new URIBuilder(url);
		addIfNotNullNorEmpty(builder, param, value);
		return builder.build();
	}

	/**
	 * Performs an HTTP request and returns the body response after decoding it, as a BEDictionary.
	 * @param requestUrl
	 * @return
	 * @throws BadTrackerResponseException
	 * @throws TrackerConnectionException
	 */
	private BEDictionary performHTTPGet(URI requestUrl) throws BadTrackerResponseException, TrackerConnectionException {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		HttpGet httpGet = new HttpGet(requestUrl);

		BEDictionary decodedResponse = null;
		try (CloseableHttpResponse response = httpclient.execute(httpGet)){
			HttpEntity responseEntity = response.getEntity();

			// doing the actual request
			decodedResponse = readAndDecodeTrackerResponse(responseEntity);

			EntityUtils.consume(responseEntity);

		} catch (DecodingException e) {
			throw new BadTrackerResponseException(e);
		} catch (IOException e) {
			throw new TrackerConnectionException(e);
		} 

		return decodedResponse;
	}

	private BEDictionary readAndDecodeTrackerResponse(HttpEntity responseEntity) throws IOException, DecodingException {
		BufferedInputStream bufIs = new BufferedInputStream(responseEntity.getContent());
		BEDictionary trackerResponse = BEncoding.decodeBEDictionary(bufIs);
		return trackerResponse;
	}

	/**
	 * Transform an announce url into a scrape url using the bittorrent protocol conventions.
	 * 
	 * @param announceUrl
	 * @returna new scrape url according to the specification, desumed from the announce url.
	 * null if the scrape url is not supported or if the conversion fails.
	 */
	public static URI toScrapeUrl(URI announceUrl) {
		String announceStr = announceUrl.toString();

		if (!announceStr.contains("announce")) {
			return null;
		}

		int lastSlashPos = announceStr.lastIndexOf('/');
		String partAfterLastSlash = announceStr.substring(lastSlashPos);

		if (partAfterLastSlash.startsWith("/announce")) {
			String scrapeUrlStr = announceStr.substring(0, lastSlashPos) + partAfterLastSlash.replaceFirst("^/announce", "/scrape");
			try {
				URI scrapeUrl = new URIBuilder(scrapeUrlStr).build();
				return scrapeUrl;

			} catch (URISyntaxException e) {
				return null; // should not happen, but if it does... well we don't support scraping
			}
		}

		return null;
	}

	public String getTrackerId() {
		return trackerId;
	}

	public void setTrackerId(String trackerId) {
		this.trackerId = trackerId;
	}

	public Map<String, String> getCustomRequestParameters() {
		return customRequestParameters;
	}

	public void setCustomRequestParameters(Map<String, String> customRequestParameters) {
		this.customRequestParameters = customRequestParameters;
	}

	private static enum Event {
		STARTED("started"),
		STOPPED("stopped"),
		COMPLETED("completed"),
		NONE("");

		private final String value;

		Event(String value) {
			this.value = value;
		}

		@Override
		public String toString() {
			return value;
		}
	}

	@Override
	public String toString() {
		return "TrackerClient [trackerUrl=" + trackerUrl + ", scrapeUrl=" + scrapeUrl + ", infoHash=" + Arrays.toString(getInfoHash())
				+ ", peerId=" + getPeerId() + ", port=" + getPort() + ", uploaded=" + getUploaded() + ", downloaded=" + getDownloaded()
				+ ", left=" + getLeft() + ", compact=" + compact + ", noPeerId=" + noPeerId + ", ip=" + ByteUtils.getIPv4(getIpAddress()) 
				+ ", numWant=" + getNumWant() + ", key=" + key + ", trackerId=" + trackerId	+ ", customRequestParameters=" 
				+ customRequestParameters + "]";
	}

	private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
		@Override
		public Thread newThread(Runnable r) {
			Thread worker = new Thread(r);
			worker.setName("HTTPTrckConn" + this.hashCode());
			worker.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

				@Override
				public void uncaughtException(Thread t, Throwable e) {
					// we want to notify only exceptions, we should not really deal with errors.
					if (e instanceof Exception) {
						notifyListeners((Exception)e);
					} else {
						// TODO log properly
						e.printStackTrace();
					}
				}
			});
			return worker;
		}
	});

	private volatile boolean doRun;

	@Override
	public void start() {
		doRun = true;
		executor.execute(new Runnable() {
			@Override
			public void run() {
				HTTPTrackerResponse response = null;

				// first started request
				try {
					response = request(Event.STARTED);
				} catch (BadTrackerResponseException | TrackerConnectionException | BadTrackerUrlException e) {
					e.printStackTrace();
					notifyListeners(e);
				}

				do {
					handleResponse(response); // this method will sleep and perform new requests as needed.
				} while (doRun);

				// when we're gracefully shutting down
				try {
					request(Event.STOPPED);
				} catch (BadTrackerResponseException | TrackerConnectionException | BadTrackerUrlException e) {
					e.printStackTrace();
					notifyListeners(e);
				}
			}
		});
	}

	/**
	 * This method should handle the response, sleep the advised amount and prepare the next request.
	 * @param response
	 */
	private void handleResponse(HTTPTrackerResponse response) {
		if (response != null) {

			notifyListeners(response);
			long interval = response.getInterval();
			sleepQuietly(interval, TimeUnit.SECONDS);

			//			long up, down, left;
			//			synchronized (this) {
			//				up = getUploaded();
			//				down = getDownloaded();
			//				left = getLeft();
			//			}



		}
	}
	
	private void sleepQuietly(long time, TimeUnit unit) {
		try {
			Thread.sleep(TimeUnit.MILLISECONDS.convert(time, unit));
		} catch (InterruptedException e) {
			// TODO log properly
		}
	}

	@Override
	public void stop() {
		doRun = false;
		
		if (executor != null) {
			executor.shutdown();
		}
	}


}
